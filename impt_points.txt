node_modules
    This is a directory where all the actual code for your installed dependencies (like Express, React, etc.) lives.

    When you run npm install, all the packages listed in package.json get downloaded here.

    It can be huge because it includes nested dependencies too.

    âœ… You should not edit anything inside this folder manually.
    âŒ You should not commit it to Git â€” itâ€™s usually listed in .gitignore.

package.json

    This is the heart of any Node.js project.
    It defines:
        Project name, version
        Scripts (start, dev, etc.)
        Dependencies (express, etc.)
        Dev dependencies (nodemon, eslint, etc.)
    Itâ€™s the file you edit manually or generate with npm init.

package-lock.json

    This file locks the exact version of every installed package (and its dependencies).
    It ensures consistent installs across all environments.
    Even if package.json says "express": "^4.18.2", the lock file records the exact version like 4.18.2 and all internal dependencies.
    Generated automatically when you run npm install.
    You should commit this file to Git.

Summary Table

File/Folder	                    Purpose	                                Committed to Git?
node_modules/	        Holds all installed packages	                    âŒ (too big)
package.json	        Describes your project and dependencies	            âœ…
package-lock.json	    Locks exact versions for reproducible installs	    âœ…

The ^ symbol in a version string in package.json controls how npm updates dependencies when you run npm install.

"express": "^4.18.2"
This means: You want version 4.18.2 or any newer version that doesnâ€™t change the major version.

So it will install anything from:   >= 4.18.2 and < 5.0.0

ðŸ“¦ Version Symbols

Symbol	Meaning
^	Allow updates that do not change the first (major) version number
~	Allow updates that do not change the second (minor) version number
None	Lock to that exact version only
ðŸ”¢ Version Breakdown
In 4.18.2,
        4 = Major version
        18 = Minor version
        2 = Patch version

Why ^ is Common
It's safe (no breaking changes), but allows you to get bug fixes and minor features.
For libraries like Express, this ensures stability unless a major update (like v5) is released.


The ".use" matches all the HTTP method api call to /user
app.use("/user", (req, res) => {
    res.send("Hello from the server")
})

This matches any route which has "/", after that what ever is there, it doessn't matter.
the order or routes are very important, if we will keep this at the top, all the routes will use this.
app.use("/", (req, res) => {
    res.send("Hello from the dashboard")
})

Pattern	                Matches Example	                    Description
/ab?cd	                /abcd, /acd	                        b is optional
/ab+cd	                /abcd, /abbcd	                    b one or more
/ab*cd	                /abcd, /ab123cd	                    Anything between ab and cd
/ab(cd)?e	            /abe, /abcde	                    Group (cd) is optional
/a/	                    /a, /abc, /bat	                    Any route containing "a"
/.*fly$/	            /butterfly, /dragonfly	            Ends with "fly"

Query Parameters (?key=value): Accessed using req.query.
    Example: req.query.search or req.query.page.
    app.get("/user/:id/profile", (req, res) => {
        const {id} = req.params
        res.send(req.query)
        res.send(`id is : ${id} and queried for ${JSON.stringify(req.query)}`)
    })

Dynamic Route Parameters (/route/:param): Accessed using req.params.
    Example: req.params.id or req.params.category.

Q. Why do we need to do JSOn.stringify?

    JavaScript cannot automatically convert an object into a string in a way that makes sense for sending over HTTP or displaying to a user. Hereâ€™s why:

    String Interpolation: When you try to directly embed an object inside a string (e.g., in a template literal), JavaScript has no way to automatically guess how to represent the complex object as a simple string.

    If you try to use an object like { name: "shri", age: "25" } inside a template string:  

        const person = { name: "shri", age: "25" };
        console.log(`The person is: ${person}`);

        JavaScript will try to convert the object into a string using its internal .toString() method, which defaults to:   [object Object]

        So the output will be:  The person is: [object Object]


        const person = { name: "shri", age: "25" };
        const jsonString = JSON.stringify(person);
        console.log(jsonString);  // '{"name":"shri","age":"25"}'

for one path, we can have multiple request handlers.
app.get("/path", rg1, rh2, rh3, rh4)


They can also be put inside array
app.get("/path", rh1, [rh2, rh3], rh4)

We can also separate the app.get

like: 
app.get("/path", rh1, rh2)
app.get("/path", rh3, rh4)

If we have put a res.send and when other res.send is encountered, then it will throw error, 
saying we can not send the headers again

When we call next(), a new functional context is created and pushed. 
Then after that call is completed, the command comes back to hat line again.


- next()
    next() is used to move to the next middleware/route.
    It's required if you want to run multiple functions in sequence for a request.
    If you forget to call next() and don't send a response, the request hangs.
    Very helpful for modular and readable code.




